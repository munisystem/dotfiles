HISTSIZE=65535
SAVEHIST=65535
setopt hist_ignore_all_dups
setopt hist_no_store
setopt hist_ignore_space
setopt hist_reduce_blanks
setopt extended_history
setopt share_history
setopt append_history

[[ -x $(which starship) ]] && eval "$(starship init zsh)"

if [[ ! -f $HOME/.zi/bin/zi.zsh ]]; then
  sh -c "$(curl -fsSL get.zshell.dev)" -- -i skip -b main
fi

source "$HOME/.zi/bin/zi.zsh"
autoload -Uz _zi
(( ${+_comps} )) && _comps[zi]=_zi

autoload -Uz compinit
compinit
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z} r:|[-_.]=**'

zi wait lucid light-mode for \
atinit"zicompinit; zicdreplay" \
    zdharma/fast-syntax-highlighting \
blockf \
  zsh-users/zsh-completions

zi light marlonrichert/zsh-autocomplete
zi light agkozak/zsh-z

[[ -x $(which fzf) ]] && source <(fzf --zsh)
[[ -x $(which direnv) ]] && source <(direnv hook zsh)
[[ -x $(which chezmoi) ]] && source <(chezmoi completion zsh)

# Support OSC 133
_prompt_executing=""
function __prompt_precmd() {
    local ret="$?"
    if test "$_prompt_executing" != "0"
    then
      _PROMPT_SAVE_PS1="$PS1"
      _PROMPT_SAVE_PS2="$PS2"
      PS1=$'%{\e]133;P;k=i\a%}'$PS1$'%{\e]133;B\a\e]122;> \a%}'
      PS2=$'%{\e]133;P;k=s\a%}'$PS2$'%{\e]133;B\a%}'
    fi
    if test "$_prompt_executing" != ""
    then
       printf "\033]133;D;%s;aid=%s\007" "$ret" "$$"
    fi
    printf "\033]133;A;cl=m;aid=%s\007" "$$"
    _prompt_executing=0
}
function __prompt_preexec() {
    PS1="$_PROMPT_SAVE_PS1"
    PS2="$_PROMPT_SAVE_PS2"
    printf "\033]133;C;\007"
    _prompt_executing=1
}
preexec_functions+=(__prompt_preexec)
precmd_functions+=(__prompt_precmd)

if [[ -f "$HOME/.env-secrets" ]]; then
  source "$HOME/.env-secrets"
fi

# functions
__fzf_history() {
  BUFFER=$(history -n -r 1 | fzf --query "$LBUFFER")
  CURSOR=$#BUFFER
  zle reset-prompt
}
zle -N __fzf_history

## support cd to git repositories
__fzf_ghq() {
  local selected_dir=$(ghq list -p | fzf --reverse)
  if [[ -n "$selected_dir" ]]; then
    BUFFER="cd ${selected_dir}"
    zle accept-line
  fi
  zle reset-prompt
}
zle -N __fzf_ghq

## extends git switch for supporting git worktree
__git_switch() {
  local branch
  branch=$(git branch --format='%(refname:short)' | fzf --reverse)

  [[ -z "$branch" ]] && return 0

  local worktree_path
  worktree_path=$(git worktree list --porcelain | awk -v branch="$branch" '
    /^worktree / { path = substr($0, 10) }
    /^branch / {
      b = $2
      sub(/^refs\/heads\//, "", b)
      if (b == branch) { print path; exit }
    }
  ')

  if [[ -n "$worktree_path" ]]; then
    cd "$worktree_path"
  else
    git switch "$branch"
  fi
}

## utility to create git worktree like a git switch -c
__git_worktree_switch() {
  local branch="$1"
  if [[ -z "$branch" ]]; then
    echo "Usage: __git_worktree_switch <branch>" >&2
    return 1
  fi

  local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
  if [[ -z "$git_root" ]]; then
    echo "Not a git repository" >&2
    return 1
  fi

  local worktree_path="${git_root}/.worktrees/${branch}"

  if git show-ref --verify --quiet "refs/heads/${branch}"; then
    git worktree add "$worktree_path" "$branch" && cd "$worktree_path"
  else
    git worktree add -b "$branch" "$worktree_path" && cd "$worktree_path"
  fi
}

## utility to delete git branch
__git_branch_delete() {
  local branch="$1"
  if [[ -z "$branch" ]]; then
    branch=$(git branch --format='%(refname:short)' | grep -v '^main$\|^master$' | fzf --reverse)
    [[ -z "$branch" ]] && return 0
  fi

  local default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
  [[ -z "$default_branch" ]] && default_branch="main"

  if [[ "$branch" == "$default_branch" || "$branch" == "main" || "$branch" == "master" ]]; then
    echo "Cannot delete $branch branch" >&2
    return 1
  fi

  if ! git show-ref --verify --quiet "refs/heads/$branch"; then
    echo "Branch $branch does not exist" >&2
    return 1
  fi

  local merged=$(git branch --merged "$default_branch" | tr -d ' +*' | grep -x "$branch")
  local force=false
  if [[ -z "$merged" ]]; then
    echo "Branch $branch is not merged."
    read -q "reply?Delete anyway? [y/N] "
    echo
    if [[ "$reply" == "y" ]]; then
      force=true
    else
      return 1
    fi
  fi

  local worktree=$(git worktree list --porcelain | awk -v b="$branch" '
    /^worktree /{p=substr($0,10)}
    /^branch /{gsub(/refs\/heads\//,"",$2); if($2==b){print p;exit}}')

  local main_worktree=$(git worktree list --porcelain | awk '/^worktree /{print substr($0,10); exit}')

  if [[ -n "$worktree" ]]; then
    cd "$main_worktree"
    git worktree remove "$worktree"
  fi

  if [[ "$force" == true ]]; then
    git branch -D "$branch"
  else
    git branch -d "$branch"
  fi
}

# keybinds
bindkey -d
bindkey -e
bindkey '^]''r' __fzf_ghq
bindkey '^r' __fzf_history

# aliases
if [[ -f "/opt/homebrew/share/zsh-abbr/zsh-abbr.zsh" ]]; then
  source /opt/homebrew/share/zsh-abbr/zsh-abbr.zsh

  [[ -x $(which exa) ]] && abbr add --quieter --force ls='exa --icons'
  [[ -x $(which bat) ]] && abbr add --quieter --force cat='bat'
  [[ -x $(which fd) ]] && abbr add --quieter --force find='fd'
  [[ -x $(which chezmoi) ]] && abbr add --quieter ch=chezmoi
  abbr add --quieter --force 'git sw'='__git_switch'
  abbr add --quieter --force 'git wt'='__git_worktree_switch'
  abbr add --quieter --force 'git bd'='__git_branch_delete'
fi
